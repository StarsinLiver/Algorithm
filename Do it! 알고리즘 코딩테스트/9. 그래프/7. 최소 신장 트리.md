## ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬

ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ (minimum spanning tree)ë€ ê·¸ë˜í”„ì—ì„œ ëª¨ë“  ë…¸ë“œë¥¼ ì—°ê²°í•  ë•Œ ì‚¬ìš©ëœ ì—ì§€ë“¤ì˜ ê°€ì¤‘ì¹˜ì˜ í•©ì„ ìµœì†Œë¡œ í•˜ëŠ” íŠ¸ë¦¬ì…ë‹ˆë‹¤. ì£¼ìš” íŠ¹ì§•ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

> ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ì˜ íŠ¹ì§•

- ì‚¬ì´í´ì´ í¬í•¨ë˜ë©´ ê°€ì¤‘ì¹˜ì˜ í•©ì´ ìµœì†Œê°€ ë  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ì‚¬ì´í´ì„ í¬í•¨í•˜ì§€ ì•ŠëŠ”ë‹¤.
- Nê°œì˜ ë…¸ë“œê°€ ìˆìœ¼ë©´ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ë¥¼ êµ¬ì„±í•˜ëŠ” ì—ì§€ì˜ ê°œìˆ˜ëŠ” í•­ìƒ N - 1ê°œ ì´ë‹¤.

### ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ì˜ í•µì‹¬ ì´ë¡ 

#### 1. ì—ì§€ ë¦¬ìŠ¤íŠ¸ë¡œ ê·¸ë˜í”„ë¥¼ êµ¬í˜„í•˜ê³  ìœ ë‹ˆì˜¨ íŒŒì¸ë“œ ë°°ì—´ ì´ˆê¸°í™”í•˜ê¸°

ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ëŠ” ë°ì´í„°ë¥¼ ë…¸ë“œê°€ ì•„ë‹Œ ì—ì§€ ì¤‘ì‹¬ìœ¼ë¡œ ì €ì¥í•˜ë¯€ë¡œ ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ê°€ ì•„ë‹Œ ì—ì§€ ë¦¬ìŠ¤íŠ¸ í˜•íƒœë¡œ ì €ì¥í•©ë‹ˆë‹¤. ì´ ë¦¬ìŠ¤íŠ¸ëŠ” ë…¸ë“œ ë³€ìˆ˜ 2ê°œì™€ ê°€ì¤‘ì¹˜ ë³€ìˆ˜ë¡œ êµ¬ì„±ë©ë‹ˆë‹¤. ì‚¬ì´í´ ì²˜ë¦¬ë¥¼ ìœ„í•œ ìœ ë‹ˆì˜¨ íŒŒì¸ë“œ ë°°ì—´ë„ í•¨ê»˜ ì´ˆê¸°í™”í•©ë‹ˆë‹¤. ë°°ì—´ì˜ ì¸ë±ìŠ¤ë¡œ í•´ë‹¹ ìë¦¬ì˜ ê°’ì„ ì´ˆê¸°í™”í•˜ë©´ ë©ë‹ˆë‹¤.

![alt text](image-80.png)

#### 2. ê·¸ë˜í”„ ë°ì´í„°ë¥¼ ê°€ì¤‘ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•˜ê¸°

ì—ì§€ ë¦¬ìŠ¤íŠ¸ì— ë‹´ê¸´ ê·¸ë˜í”„ ë°ì´í„°ë¥¼ ê°€ì¤‘ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬í•©ë‹ˆë‹¤.

![alt text](image-81.png)

> ì—ì§€ ë¦¬ìŠ¤íŠ¸ì˜ 1ê°œ ê°ì²´ë¥¼ êµ¬ì¡°ì²´ (struct)ë¡œ í‘œí˜„í•˜ë©´ operator() í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ ë†’ì€ ììœ ë„ë¡œ ì •ë ¬ì„ ìˆ˜í–‰í•  ã…… ã…œìˆìŠµë‹ˆë‹¤.

#### 3. ê°€ì¤‘ì¹˜ê°€ ë‚®ì€ ì—ì§€ë¶€í„° ì—°ê²° ì‹œë„í•˜ê¸°

ê°€ì¤‘ì¹˜ê°€ ë‚®ì€ ì—ì§€ë¶€í„° ìˆœì„œëŒ€ë¡œ ì„ íƒí•´ ì—°ê²°ì„ ì‹œë„í•©ë‹ˆë‹¤. ì´ë•Œ ë°”ë¡œ ì—°ê²°í•˜ì§€ ì•Šê³  ì´ ì—ì§€ë¥¼ ì—°ê²°í–ˆì„ ë•Œ ê·¸ë˜í”„ì— ì‚¬ì´í´ í˜•ì„± ì—¬ë¶€ë¥¼ find ì—°ì‚°ì„ ì´ìš©í•´ í™•ì¸í•œ í›„ ì‚¬ì´í´ì´ í˜•ì„± ë˜ì§€ ì•Šì„ ë•Œë§Œ union ì—°ì‚°ì„ ì´ìš©í•´ ë‘ ë…¸ë“œë¥¼ ì—°ê²°í•©ë‹ˆë‹¤.

![alt text](image-82.png)

#### 4. ê³¼ì • 3 ë°˜ë³µí•˜ê¸°

ì „ì²´ ë…¸ë“œì˜ ê°œìˆ˜ê°€ Nê°œì´ë©´ ì—°ê²°í•œ ì—ì§€ì˜ ê°œìˆ˜ê°€ N - 1ì´ ë  ë•Œ ê¹Œì§€ ê³¼ì • 3ì„ ë°˜ë³µí•©ë‹ˆë‹¤.

![alt text](image-83.png)

#### 5. ì´ ì—ì§€ ë¹„ìš© ì¶œë ¥í•˜ê¸°

ì—ì§€ì˜ ê°œìˆ˜ê°€ N - 1ì´ ë˜ë©´ ì•Œê³ ë¦¬ì¦˜ì„ ì¢…ë£Œí•˜ê³  ì™„ì„±ëœ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ì˜ ì´ ì—ì§€ ë¹„ìš©ì„ ì¶œë ¥í•©ë‹ˆë‹¤.

![alt text](image-84.png)

```
ì´ ì—ì§€ ë¹„ìš©
= 2 + 3 + 4 + 8
= 17
ğŸ’•ì´ 17 ì¶œë ¥
```

ìµœì†Œ ì‹±ì¥ íŠ¸ë¦¬ëŠ” ë‹¤ë¥¸ ê·¸ë˜í”„ ì•Œê³ ë¦¬ì¦˜ê³¼ëŠ” ë‹¬ë¦¬, ì—ì§€ ë¦¬ìŠ¤íŠ¸ í˜•íƒœë¥¼ ì´ìš©í•´ ë°ì´í„°ë¥¼ ë‹´ëŠ”ë‹¤ëŠ” íŠ¹ì§•ì´ ìˆìŠµë‹ˆë‹¤. ê·¸ ì´ìœ ëŠ” ì—ì§€ë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ë˜í•œ ì‚¬ì´í´ì´ ì¡´ì¬í•˜ë©´ ì•ˆë˜ëŠ” íŠ¹ì§•ì„ ì§€ë‹ˆê³  ìˆê¸° ë•Œë¬¸ì— ì‚¬ì´í´ íŒë³„ ì•Œê³ ë¦¬ì¦˜ì¸ ìœ ë‹ˆì˜¨ íŒŒì¸ë“œ ì•Œê³ ë¦¬ì¦˜ì„ ë‚´ë¶€ì— êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤.

---

### $[ë¬¸ì œ067]$ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ êµ¬í•˜ê¸°

![alt text](image-85.png)

### $[01ë‹¨ê³„]$ ë¬¸ì œ ë¶„ì„í•˜ê¸°

ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ë¥¼ êµ¬í•˜ëŠ” ê°€ì¥ ê¸°ë³¸ì ì¸ ë¬¸ì œì…ë‹ˆë‹¤. ë¬¸ì œì˜ ë‚´ìš© ìì²´ê°€ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ì— ê´€í•´ ì„¤ëª…í•˜ê³  ìˆê¸° ë•Œë¬¸ì— ì•ì—ì„œ ë°°ìš´ í•µì‹¬ ì´ë¡ ì„ ì´ìš©í•˜ë©´ ì´ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### $[02ë‹¨ê³„]$ ì†ìœ¼ë¡œ í’€ì–´ë³´ê¸°

1. ì—ì§€ ë¦¬ìŠ¤íŠ¸ì— ì—ì§€ ì •ë³´ë¥¼ ì €ì¥í•œ í›„ ë¶€ëª¨ ë…¸ë“œ ë°ì´í„°ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤. ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ëŠ” ì—ì§€ ì¤‘ì‹¬ì˜ ì•Œê³ ë¦¬ì¦˜ì´ë¯€ë¡œ ë°ì´í„°ë¥¼ ì—ì§€ ë¦¬ìŠ¤íŠ¸ë¥¼ í™œìš©í•´ ì €ì¥í•´ì•¼ í•©ë‹ˆë‹¤.

![alt text](image-87.png)

2. í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤. í˜„ì¬ ë¯¸ì‚¬ìš© ì—ì§€ ì¤‘ ê°€ì¤‘ì¹˜ê°€ ê°€ì¥ ì‘ì€ ì—ì§€ë¥¼ ì„ íƒí•˜ê³ , ì´ ì—ì§€ë¥¼ ì—°ê²°í–ˆì„ ë•Œ ì‚¬ì´í´ì˜ ë°œìƒ ì—¬ë¶€ë¥¼ íŒë‹¨í•©ë‹ˆë‹¤. ì‚¬ì´í´ì´ ë°œìƒí•¨ë…€ ìƒëµí•˜ê³ , ë°œìƒí•˜ì§€ ì•Šìœ¼ë©´ ì—ì§€ê°’ì„ ë”í•©ë‹ˆë‹¤.

> í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œë„ ê°€ëŠ¥í•©ë‹ˆë‹¤.

![alt text](image-88.png)

3. ê³¼ì • 2ì—ì„œ ì—ì§€ë¥¼ ë”í•œ íšŸìˆ˜ê°€ 'V(ë…¸ë“œ ê°œìˆ˜) - 1'ì´ ë  ë•Œê¹Œì§€ ë°˜ë³µí•˜ê³ , ë°˜ë³µì´ ëë‚˜ë©´ ì—ì§€ì˜ ê°€ì¤‘ì¹˜ë¥¼ ëª¨ë‘ ë”í•œ ê°’ì„ ì¶œë ¥í•©ë‹ˆë‹¤.

![alt text](image-89.png)

```
V(ë…¸ë“œ ê°œìˆ˜) - 1 = 3 - 1 = 2
=> ì—ì§€ë¥¼ 2ê°œ ì¶”ê°€í–ˆìœ¼ë¯€ë¡œ ì•Œê³ ë¦¬ì¦˜ ì¢…ë£Œ
=> ì—ì§€ì˜ ê°€ì¤‘ì¹˜ í•© ì¶œë ¥
=> 3
```

### $[03ë‹¨ê³„]$ ìŠˆë„ì½”ë“œ ì‘ì„±í•˜ê¸°

```
N (ë…¸ë“œ ìˆ˜), M(ì—ì§€ ìˆ˜)
parent (ëŒ€í‘œ ë…¸ë“œ ì €ì¥ ë°°ì—´)
Edge   (ì—ì§€ ì •ë³´ ì €ì¥ struct) // ê°€ì¤‘ì¹˜ ê¸°ì¤€ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬ìœ¼ë¡œ ì„¤ì • -> ì—°ì‚°ì ì˜¤ë²„ë¡œë”©
pq     (ì—ì§€ ì •ë³´ë¥¼ ì €ì¥í•  ìš°ì„ ìˆœìœ„ í) // ì €ì¥ ë°ì´í„° type ë¥¼ struct Edge ë¡œ ì„¤ì •

for (N ë§Œí¼ ë°˜ë³µ)
  parent ë°°ì—´ ì´ˆê¸°í™” // ìê¸° ìì‹ ì˜ index ê°’ìœ¼ë¡œ ì´ˆê¸°í™”
for (M ë§Œí¼ ë°˜ë³µ)
  queueì— ì—ì§€ ì •ë³´ ì €ì¥

while (ì‚¬ìš©í•œ ì—ì§€ ìˆ˜ê°€ ë…¸ë“œ -1ì´ ë  ë•Œê¹Œì§€) {
  queue ì—ì„œ ì—ì§€ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
  // ì—°ê²°í•´ë„ ì‚¬ì´í´ì´ ìƒê¸°ì§€ ì•Šìœ¼ë©´
  if (ì—ì§€ ì‹œì‘ì ê³¼ ëì ì˜ ë¶€ëª¨ ë…¸ë“œê°€ ë‹¤ë¥´ë©´) {
    union ì—°ì‚° ìˆ˜í–‰
    ì—ì§€ì˜ ê°€ì¤‘ì¹˜ë¥¼ ì •ë‹µ ë³€ìˆ˜ì— ë”í•˜ê¸°
    ì‚¬ìš© ì—ì§€ ìˆ˜ 1 ì¦ê°€
  }
}

ì •ë‹µ ë³€ìˆ˜ ì¶œë ¥

---

// union ì—°ì‚°
union (a,b) {
  aì™€ bì˜ ëŒ€í‘œ ë…¸ë“œ ì°¾ê¸°
  ë‘ ì›ì†Œì˜ ëŒ€í‘œ ë…¸ë“œë¼ë¦¬ ì—°ê²°í•˜ê¸°
}

// find ì—°ì‚°
find (a) {
  aê°€ ëŒ€í‘œ ë…¸ë“œë©´ ë°˜í™˜
  ì•„ë‹ˆë©´ aì˜ ëŒ€í‘œ ë…¸ë“œ ê°’ì„ find(parent[a]) ê°’ìœ¼ë¡œ ì €ì¥ -> ì¬ê·€í•¨ìˆ˜
}
```

### $[04ë‹¨ê³„]$ ì½”ë“œ êµ¬í˜„í•˜ê¸°

```c
#include <iostream>
#include <queue>
using namespace std;

void munion(int a, int b);

int find(int a);

static vector<int> parent;

// ì—ì§€ ì •ë³´ êµ¬ì¡°ì²´ ìƒì„±, ê°€ì¤‘ì¹˜ ê°’ ê¸°ì¤€ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬ë¡œ ì„¤ì •
typedef struct Edge {
    int s, e, v;

    bool operator >(const Edge &temp) const {
        return v > temp.v;
    }
} Edge;

int main(int argc, char *argv[]) {
    int N, M;
    cin >> N >> M;
    priority_queue<Edge, vector<Edge>, greater<Edge> > pq; // ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
    parent.resize(N + 1);

    // parent ë°°ì—´ ì´ˆê¸°í™”
    for (int i = 0; i <= N; i++) {
        parent[i] = i;
    }
    // queueì— ì—ì§€ ì •ë³´ ì €ì¥
    for (int i = 0; i < M; i++) {
        int s, e, v;
        cin >> s >> e >> v;
        pq.push(Edge{s, e, v});
    }

    // --- ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ ì•Œê³ ë¦¬ì¦˜ ì‹¤í–‰
    int useEdge = 0;
    int result = 0;

    while (useEdge < N - 1) {
        Edge now = pq.top();
        pq.pop();

        // ê°™ì€ ë¶€ëª¨ê°€ ì•„ë‹ˆë¼ë©´ -> ì—°ê²°í•´ë„ ì‚¬ì´í´ì´ ìƒê¸°ì§€ ì•ŠëŠ”ë‹¤ë©´
        if (find(now.s) != find(now.e)) {
            munion(now.s, now.e);
            result = result + now.v;
            useEdge++;
        }
    }
    // --- ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ ì•Œê³ ë¦¬ì¦˜ ì¢…ë£Œ

    cout << result;
    return 0;
}

// union ì—°ì‚°
void munion(int a, int b) {
    a = find(a);
    b = find(b);
    if (a != b)
        parent[b] = a;
}

// find ì—°ì‚°
int find(int a) {
    if (a == parent[a])
        return a;
    else
        return parent[a] = find(parent[a]);
}
```

---

### $[ë¬¸ì œ068]$ ë‹¤ë¦¬ ë§Œë“¤ê¸°

> ë„ˆë¬´ ê¸¸ì–´ì„œ ë§í¬ë¡œ ëŒ€ì²´

https://www.acmicpc.net/problem/17472

### $[01ë‹¨ê³„]$ ë¬¸ì œ ë¶„ì„í•˜ê¸°

ë¬¸ì œ ì¡°ê±´ì—ì„œ ë°ì´í„°ì˜ í¬ê¸°ëŠ” ë§¤ìš° ì‘ì€ í¸ì´ë¼ ì‹œê°„ ë³µì¡ë„ ì œì•½ì€ í¬ì§€ ã…‡ë‚³ìŠµë‹ˆë‹¤. ë‹¨ ëª‡ê°œì˜ ë‹¨ê³„ë¡œ ë‚˜ëˆ  ìƒê°í•´ì•¼ í•  ë¬¸ì œì…ë‹ˆë‹¤. ë¨¼ì € ì£¼ì–´ì§„ ì§€ë„ì—ì„œ ì„¬ìœ¼ë¡œ í‘œí˜„ëœ ê°’ì„ ê°ê°ì˜ ì„¬ë§ˆë‹¤ ë‹¤ë¥´ê²Œ í‘œí˜„í•´ì•¼ í•©ë‹ˆë‹¤. ê·¸ ì´í›„ ê° ì„¬ì˜ ëª¨ë“  ìœ„ì¹˜ì—ì„œ ë‹¤ë¥¸ ì„¬ìœ¼ë¡œ ì—°ê²°í•  ìˆ˜ ìˆëŠ” ì—ì§€ê°€ ìˆëŠ”ì§€ í™•ì¸í•´ ì—ì§€ ë¦¬ìŠ¤íŠ¸ë¥¼ ë§Œë“­ë‹ˆë‹¤. ì´í›„ì—ëŠ” ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ë¥¼ ì ìš©í•˜ë©´ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### $[02ë‹¨ê³„]$ ì†ìœ¼ë¡œ í’€ì–´ë³´ê¸°

1. ì§€ë„ì˜ ì •ë³´ë¥¼ 2ì°¨ì› ë°°ì—´ì— ì €ì¥í•˜ê³  ì„¬ìœ¼ë¡œ í‘œì‹œëœ ëª¨ë“  ì ì—ì„œ BFSë¥¼ ì‹¤í–‰í•´ ì„¬ì„ êµ¬ë¶„í•©ë‹ˆë‹¤. (ìƒí•˜ì¢Œìš° ë„¤ë°©í–¥ìœ¼ë¡œ íƒìƒ‰). ë°©ë¬¸í•œ ì ì´ ì—†ê³  ë°”ë‹¤ê°€ ì•„ë‹ë•Œ ê°™ì€ ì„¬ìœ¼ë¡œ ì¸ì‹í•©ë‹ˆë‹¤.

![alt text](image-90.png)

2. ëª¨ë“  ì„¬ì—ì„œ ìƒí™”ì¢Œìš°ë¡œ ë‹¤ë¥´ë¥¼ ì§€ì–´ ë‹¤ë¥¸ ì„¬ìœ¼ë¡œ ì—°ê²°í•  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤. ì—°ê²°í•  ê³³ì´ í˜„ì¬ ì„¬ì´ë©´ ë‹´ìƒ‰ ì¤‘ë‹¨ ë°”ë‹¤ë¼ë©´ ë‹´ìƒ‰ì„ ê³„ì† ìˆ˜í–‰í•©ë‹ˆë‹¤. ë‹¤ë¥¸ì„¬ì„ ë§Œë‚¬ì„ ë•Œ ë‹¤ë¦¬ì˜ ê¸¸ì´ê°€ 2 ì´ìƒì´ë©´ ì´ ë‹¤ë¦¬ë¥¼ ì—ì§€ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€í•©ë‹ˆë‹¤.

![alt text](image-91.png)

3. ì „ ë‹¨ê³„ì—ì„œ ìˆ˜ì§‘í•œ ëª¨ë“  ì—ì§€ë¥¼ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬í•´ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ ì•Œê³ ë¦¬ì¦˜ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤. ì•Œê³ ë¦¬ì¦˜ì´ ëë‚˜ë©´ ì‚¬ìš©í•œ ì—ì§€ì˜ í•©ì„ ì¶œë ¥í•©ë‹ˆë‹¤.

![alt text](image-92.png)

### $[03ë‹¨ê³„]$ ìŠˆë„ì½”ë“œ ì‘ì„±í•˜ê¸°

```
dr, dc (4ë°©í–¥ íƒìƒ‰ì„ ìœ„í•œ ìƒìˆ˜)
N, M (í–‰ë ¬ì˜ í¬ê¸°)
map (ë§µ ì •ë³´ ì €ì¥ ë°°ì—´)
parent (ëŒ€í‘œ ë…¸ë“œ ì €ì¥ ë°°ì—´)
visited (BFS ì‹œ ë°©ë¬¸ ì—¬ë¶€ ì €ì¥ ë°°ì—´)

sumlist (ëª¨ë“  ì„¬ ì •ë³´ ì €ì¥)
mlist (í•˜ë‚˜ì˜ ì„¬ ì •ë³´ ì €ì¥)
Edge (ì—ì§€ ì •ë³´ ì €ì¥ êµ¬ì¡°ì²´)        // ê°€ì¤‘ì¹˜ ê°’ ê¸°ì¤€ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬ë¡œ ì„¤ì •
pq (ë‹¤ë¦¬ ì •ë³´ë¥¼ ì €ì¥í•  ìš°ì„ ìˆœìœ„ í) // ì €ì¥ ë°ì´í„° ìœ í˜•ì„ êµ¬ì¡°ì²´ Edgeë¡œ ì„¤ì •

// MAP ì •ë³´ ì €ì¥
for (N ë§Œí¼ ë°˜ë³µ)
  for (M ë§Œí¼ ë°˜ë³µ)
    ì…ë ¥ ë°ì´í„°ë¥¼ map ë³€ìˆ˜ì— ì €ì¥

// ì„¬ ë¶„ë¦¬ ì‘ì—… ì‹¤í–‰
for (i -> N ë§Œí¼ ë°˜ë³µ)
  for (j -> N ë§Œí¼ ë°˜ë³µ) {
    BFS(i,j) ëª¨ë“  ìœ„ì¹˜ì—ì„œ BFSë¥¼ ì‹¤í–‰í•˜ì—¬ ì„¬ì„ ë¶„ë¦¬
    ê²°ê³¼ë¥¼ sumlist ë³€ìˆ˜ì— ë„£ê¸°
  }

// ëª¨ë“  ì„¬ì—ì„œ ì§€ì„ ìˆ˜ ìˆëŠ” ë‹¤ë¦¬ë¥¼ ì°¾ê³  ì €ì¥í•˜ê¸°
for (i -> sumlist í¬ê¸° ë§Œí¼ ë°˜ë³µ) {
  now = sumlistì—ì„œ ì„¬ ì •ë³´ ì¶”ì¶œ
  for (j -> now í¬ê¸°ë§Œí¼ ë°˜ë³µ) {
    í•˜ë‚˜ì˜ ì„¬ì˜ ëª¨ë“  ìœ„ì¹˜ì—ì„œ ë§Œë“¤ ìˆ˜ ìˆëŠ” ë‹¤ë¦¬ ì •ë³´ ì €ì¥ // 4ë°©í–¥ íƒìƒ‰
    -> íì— ì—ì§€ ì •ë³´ ì €ì¥
  }
}

for (ì„¬ì˜ ìˆ˜ë§Œí¼ ë°˜ë³µ) {
  parent ë°°ì—´ ì´ˆê¸°í™” // ìê¸° ìì‹ ì˜ index ê°’ìœ¼ë¡œ ì´ˆê¸°í™”
}

// ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ ì•Œê³ ë¦¬ì¦˜ ìˆ˜í–‰
while (íê°€ ë¹Œ ë•Œê¹Œì§€) {
  queue ì—ì„œ ì—ì§€ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
  // ì—°ê²°í•´ë„ ì‚¬ì´í´ì´ ìƒê¸°ì§€ ì•Šìœ¼ë©´
  if (ì—ì§€ ì‹œì‘ì ê³¼ ëì ì˜ ë¶€ëª¨ ë…¸ë“œê°€ ë‹¤ë¥´ë©´) {
    union ì—°ì‚° ìˆ˜í–‰
    ì—ì§€ì˜ ê°€ì¤‘ì¹˜ë¥¼ ì •ë‹µ ë³€ìˆ˜ì— ë”í•˜ê¸°
    ì‚¬ìš© ì—ì§€ ìˆ˜ ì¦ê°€ì‹œí‚¤ê¸°
  }
}

ì‚¬ìš©í•œ ì—ì§€ê°€ ì„¬ì˜ ìˆ˜ -1ë§Œí¼ì´ë©´ ê°€ì¤‘ì¹˜ì˜ í•©ì„ ê²°ê³¼ë¡œ ì¶œë ¥ ì•„ë‹ˆë©´ -1 ì¶œë ¥

---

// union í•¨ìˆ˜
union (a,b) {
  aì™€ bì˜ ëŒ€í‘œ ë…¸ë“œ ì°¾ê¸°
  ë‘ ì›ì†Œì˜ ëŒ€í‘œ ë…¸ë“œë¼ë¦¬ ì—°ê²°í•˜ì—¬ ì£¼ê¸°
}

// find í•¨ìˆ˜
find (a) {
  a ê°€ ëŒ€í‘œ ë…¸ë“œë©´ ë°˜í™˜
  ì•„ë‹ˆë©´ aì˜ ëŒ€í‘œ ë…¸ë“œ ê°’ì„ find(parent[a]) ê°’ìœ¼ë¡œ ì €ì¥ -> ì¬ê·€í•¨ìˆ˜
}

// BFS í•¨ìˆ˜
BFS (i,j) {
  i,j ìœ„ì¹˜ì—ì„œ 4ë°©í–¥ì„ íƒìƒ‰í•˜ì—¬ í•˜ë‚˜ì˜ ì„¬ì˜ ì˜ì—­ ì €ì¥í•˜ê¸°
}
```

### $[04ë‹¨ê³„]$ ì½”ë“œ êµ¬í˜„í•˜ê¸°

```c
#include <iostream>
#include <queue>
using namespace std;

void munion(int a, int b);

int find(int a);

void BFS(int i, int j);

static int dr[] = {-1, 0, 1, 0};
static int dc[] = {0, 1, 0, -1};
static int map[101][101];
static bool visited[101][101] = {false,};
static vector<int> parent;
static int N, M, sNum;
static vector<vector<pair<int, int> > > sumlist;
static vector<pair<int, int> > mlist;

// ì—ì§€ ì •ë³´ êµ¬ì¡°ì²´ ìƒì„±, ê°€ì¤‘ì¹˜ ê°’ ê¸°ì¤€ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬ë¡œ ì„¤ì •

typedef struct Edge {
    int s, e, v;

    bool operator >(const Edge &temp) const {
        return v > temp.v;
    }
} Edge;

static priority_queue<Edge, vector<Edge>, greater<Edge> > pq; // ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬

int main(int argc, char *argv[]) {
    cin >> N >> M;

    for (int i = 0; i < N; i++)
        for (int j = 0; j < M; j++) {
            cin >> map[i][j];
        }

    sNum = 1;

    // ê° ìë¦¬ì—ì„œ BFS íƒìƒ‰ì„ ì´ìš©í•˜ì—¬ ì„¬ì„ ë¶„ë¦¬
    for (int i = 0; i < N; i++)
        for (int j = 0; j < M; j++) {
            if (map[i][j] != 0 && visited[i][j] != true) {
                BFS(i, j);
                sNum++;
                sumlist.push_back(mlist);
            }
        }

    // ì„¬ì˜ ê° ì§€ì ì—ì„œ ë§Œë“¤ ìˆ˜ ìˆëŠ” ëª¨ë“  ì—ì§€ë¥¼ ì €ì¥
    for (int i = 0; i < sumlist.size(); i++) {
        vector<pair<int, int> > now = sumlist[i];

        for (int j = 0; j < now.size(); j++) {
            int r = now[j].first;
            int c = now[j].second;
            int now_S = map[r][c];

            for (int d = 0; d < 4; d++) {
                int tempR = dr[d];
                int tempC = dc[d];
                int blength = 0;

                while (r + tempR >= 0 && r + tempR < N && c + tempC >= 0 && c + tempC < M) {
                    // ê°™ì€ ì„¬ì´ë©´ ì—ì§€ë¥¼ ë§Œë“¤ ìˆ˜ ì—†ìŒ
                    if (map[r + tempR][c + tempC] == now_S) {
                        break;
                    }
                    // ê°™ì€ ì„¬ì´ ì•„ë‹ˆê³  ë°”ë‹¤ê°€ ì•„ë‹ˆë©´
                    else if (map[r + tempR][c + tempC] != 0) {
                        // ë‹¤ë¥¸ ì„¬ -> ê¸¸ì´ê°€ 1 ì´ˆê³¼ì¼ ë•Œ ì—ì§€ë¡œ ë”í•˜ê¸°
                        if (blength > 1) {
                            pq.push(Edge{now_S, map[r + tempR][c + tempC], blength});
                        }
                        break;
                    }
                    // ë°”ë‹¤ì´ë©´ ë‹¤ë¦¬ ê¸¸ì´ ì—°ì¥í•˜ê¸°
                    else {
                        blength++;
                    }
                    if (tempR < 0)
                        tempR--;
                    else if (tempR > 0)
                        tempR++;
                    else if (tempC < 0)
                        tempC--;
                    else if (tempC > 0)
                        tempC++;
                }
            }
        }
    }

    // --- ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ ì‹¤í–‰
    parent.resize(sNum);
    for (int i = 0; i < parent.size(); i++)
        parent[i] = i;

    int useEdge = 0;
    int result = 0;

    while (!pq.empty()) {
        Edge now = pq.top();
        pq.pop();
        // ê°™ì€ ë¶€ëª¨ê°€ ì•„ë‹ˆë¼ë©´ == ì—°ê²°ê°€ëŠ¥
        if (find(now.s) != find(now.e)) {
            munion(now.s, now.e);
            result = result + now.v;
            useEdge++;
        }
    }
    // --- ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ ì¢…ë£Œ

    // ë°°ì—´ì—ì„œ ì‰½ê²Œ indexë¥¼ ì²˜ë¦¬í•˜ê³ ì sNumì„ 1ë¶€í„° ì‹œì‘í•˜ì˜€ìœ¼ë¯€ë¡œ
    // í˜„ì¬ sNumì˜ ê°’ì´ ì„¬ì˜ ê°œìˆ˜ë³´ë‹¤ 1 ë§ì€ ìƒíƒœì„
    // ê·¸ëŸ¬ë¯€ë¡œ 1 ì‘ì€ ìˆ˜ê°€ ì•„ë‹Œ 2 ì‘ì€ ìˆ˜ì™€ ì‚¬ìš© ì—ì§€ë¥¼ ë¹„êµí•¨
    if (useEdge == sNum - 2)
        cout << result << "\n";
    else
        cout << -1 << "\n";

    return 0;
}

void munion(int a, int b) {
    a = find(a);
    b = find(b);
    if (a != b)
        parent[b] = a;
}

int find(int a) {
    if (a == parent[a])
        return a;
    else
        return parent[a] = find(parent[a]);
}

void BFS(int i, int j) {
    queue<pair<int, int> > myqueue;
    mlist.clear();
    myqueue.push(make_pair(i, j));
    mlist.push_back(make_pair(i, j));
    visited[i][j] = true;
    map[i][j] = sNum;

    while (!myqueue.empty()) {
        int r = myqueue.front().first;
        int c = myqueue.front().second;
        myqueue.pop();

        // 4ë°©í–¥ ê²€ìƒ‰
        for (int d = 0; d < 4; d++) {
            int tempR = dr[d];
            int tempC = dc[d];
            while (r + tempR >= 0 && r + tempR < N && c + tempC >= 0 && c + tempC < M) {
                if (visited[r + tempR][c + tempC] == false && map[r + tempR][c + tempC] != 0) {
                    int now_i = r + tempR;
                    int now_j = c + tempC;
                    map[now_i][now_j] = sNum;
                    visited[now_i][now_j] = true;
                    mlist.push_back(make_pair(now_i, now_j));
                    myqueue.push(make_pair(now_i, now_j));
                } else {
                    break;
                }
                // íƒìƒ‰ ë°©í–¥ì— ì„¬ì´ ì´ì–´ì ¸ ìˆìœ¼ë©´ ê³„ì† íƒìƒ‰
                if (tempR < 0)
                    tempR--;
                else if (tempR > 0)
                    tempR++;
                else if (tempC < 0)
                    tempC--;
                else if (tempC > 0)
                    tempC++;
            }
        }
    }
}
```
