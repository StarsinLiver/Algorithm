## 나머지 연산의 중요성 알아보기

코딩 테스트에서는 정답을 나머지 값으로 요구하는 경우가 종종 있습니다. 보통 문제에 따라 '정답을 OO으로 나눈 나머지를 출력하세요.' 라고 적혀있습니다.

### 나머지 연산의 분배 법칙

나머지 연산은 나눗셈을 제외하고 다음과 같이 덧셈,뺄셈,곱셈의 분배 법칙이 성립합니다.

```
예시 값 : A = 20, B = 6, C = 3
```

#### 덧셈의 분배 법칙 성립 -> (A + B) % C = (A % C + B % C) % C

```
(20 + 6) % 3 = 26 % 3 = 2
(20 % 3 + 6 % 3) % 3 = (2 + 0) % 3 = 2
```

#### 뺄셈의 분배 법칙 성립 -> (A - B) % C = (A % C - B % C) % C

```
(20 - 6) % 3 = 14 % 3 = 2
(20 % 3 - 6 % 3) % 3 = (2 - 0) % 3 = 2
```

#### 곱셈의 분배 법칙 성립 -> (A \* B) % C = (A % C) \* (B % C) % C

```
(20 * 6) % 3 = 120 % 3 = 0
(20 % 3 * 6 % 3) % 3 = (2 * 0) % 3 = 0
```

#### 곱셈의 분배 법칙 성립 -> (A / B) % C != (A % C) / (B % C) % C

```
(20 / 6) % 3 = 3 % 3 = 0
(20 % 3) / (2 % 3) % 3 = (2 / 2) % 3 = 1
```

이는 문제를 구현할 때 섯셈, 뺄셈, 곱셈을 모두 계산한 후에 나머지 연산을 한번만 수행하는 것이 아니라, 로직의 중간 과정마다 지속적으로 수행함으로써 자료형의 표현 범위를 초과하지 않도록 설계할 수 있다는 의미입니다.

예를 들어봅시다. '1부터 50까지 곱한 값을 10007로 나눈 나머지를 구하시오.' 라는 문제가 있다면 먼저 다음과 같이 시도해 볼 수 있습니다.

#### 1부터 50까지 곱한 값을 10007로 나눈 나머지를 구하시오.

```c
#include <iostream>
#include <cstdlib>

using namespace std;

int main(int argc, char *argv[]) {

    long long answer = 1;
    for (int i = 1; i <= 50; i++) {
        answer *= i;
    }

    cout << answer % 10007;

    return EXIT_SUCCESS;
}
```

#### 실행결과

```
-6828
```

자연수의 곱을 계산하고 나머지를 구했는데 의도치 않게 음수가 출력되었습니다. 이는 자료형의 사용 문제이거나 로직의 문제일 수 있습니다. 로직을 자세히 살펴보면, 모든 값을 곱한 후 마지막에 나머지 연산을 수행하고 있습니다. 이 때문에 곱셈 과정에서 이미 long long 자료형의 표현 범위를 초과하여 잘못된 값이 나온 것입니다.

이 문제는 나미저 연산에서 곱셈의 분배 법칙이 성립한다는 점을 활용해 해결할 수 있습니다. 즉, 모든 값을 곱한 뒤 마지막에 나미지 연산을 한번만 적용하는 것과 곱셈을 수행할 때마다 나머지 연산을 적용하는 것이 동일한 결과를 낳습니다. 이 원리를 바탕으로 코드를 수정해 보겠습니다.

```c
#include <iostream>
#include <cstdlib>

using namespace std;

int main(int argc, char *argv[]) {

    long long answer = 1;
    for (int i = 1; i <= 50; i++) {
        answer = (answer * i) % 10007;
    }

    cout << answer;

    return EXIT_SUCCESS;
}
```

#### 실행결과

```
3235
```

이와 같이 곱셈을 실행할 때마다 나머지 연산을 함께 수행하도록 코드를 수정하면, 결과값이 정상으로 출력되는 것을 확인할 수 있습니다. 일반적으로 문제에 '결괏값을 OO으로 나눈 나머지를 출력하세요.'라는 문구가 있을 경우 정답을 구한 후 마지막에 나머지 연산을 한번만 적용하는 방법은 위험할 수 있습니다.
